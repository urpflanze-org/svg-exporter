{"version":3,"sources":["webpack://SVGExporter/webpack/universalModuleDefinition","webpack://SVGExporter/./dist/cjs/index.js","webpack://SVGExporter/./dist/cjs/types.js","webpack://SVGExporter/./dist/cjs/SVGExporter.js","webpack://SVGExporter/./node_modules/@urpflanze/color/dist/index.js","webpack://SVGExporter/./node_modules/@urpflanze/color/dist/types.js","webpack://SVGExporter/./node_modules/@urpflanze/color/dist/conversions.js","webpack://SVGExporter/./node_modules/@urpflanze/color/dist/parsing.js","webpack://SVGExporter/webpack/bootstrap","webpack://SVGExporter/webpack/startup"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;ACVa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa,mBAAO,CAAC,CAAS;AAC9B,aAAa,mBAAO,CAAC,CAAe;AACpC,iC;;;;;;ACda;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iC;;;;;;ACFa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,mBAAmB;AACnB,gBAAgB,mBAAO,CAAC,CAAkB;AAC1C;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK,YAAY,aAAa;AACnE;AACA,sCAAsC,KAAK,IAAI,+CAA+C;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc,IAAI;AAC9E,yCAAyC,YAAY,YAAY,aAAa,IAAI,oDAAoD;AACtI;AACA,qCAAqC,YAAY,GAAG,aAAa;AACjE;AACA,iCAAiC,WAAW;AAC5C,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA,6EAA6E,0BAA0B;AACvG;AACA;AACA;AACA,8EAA8E,wBAAwB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA,+DAA+D,cAAc,IAAI;AACjF;AACA,8BAA8B,kBAAkB,GAAG,4CAA4C;AAC/F,yCAAyC,EAAE,IAAI,oDAAoD;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,uC;;;;;;ACnIa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa,mBAAO,CAAC,CAAS;AAC9B,aAAa,mBAAO,CAAC,CAAe;AACpC,aAAa,mBAAO,CAAC,CAAW;AAChC,iC;;;;;;ACfa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iC;;;;;;ACFa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,GAAG,gBAAgB,GAAG,gBAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAA6D;AAC5E;AACA,gBAAgB;AAChB;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,uC;;;;;;ACzFa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB,GAAG,4BAA4B;AACjD,sBAAsB,mBAAO,CAAC,CAAe;AAC7C;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,mC;;;;;UCvGA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UCtBA;UACA;UACA;UACA","file":"urpflanze-svg-exporter.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGExporter\"] = factory();\n\telse\n\t\troot[\"SVGExporter\"] = factory();\n})(window, function() {\nreturn ","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./SVGExporter\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SVGExporter = void 0;\nconst color_1 = require(\"@urpflanze/color\");\nclass SVGExporter {\n    static parse(scene, settings = {}) {\n        const bindedSettings = {\n            ...SVGExporter.defaults,\n            ...settings,\n        };\n        return SVGExporter.generate(scene, bindedSettings);\n    }\n    /**\n     * Get drawer prop\n     *\n     * @param key name of the property (fill, stroke, lineWidth)\n     * @param propArguments currentIndexing propArguments\n     * @param defaultValue\n     *\n     * @returns string | number\n     */\n    static getSVGProp(key, propArguments, defaultValue) {\n        let attribute = propArguments.shape.drawer[key];\n        if (typeof attribute === 'function') {\n            attribute = attribute(propArguments);\n        }\n        return attribute !== null && attribute !== void 0 ? attribute : defaultValue;\n    }\n    /**\n     *\n     * @param type fill | stroke\n     * @param color string\n     * @param attriburesPtr list of attributes to apply\n     * @param stylePtr Array of string to put in style attr\n     *\n     * @returns\n     */\n    static bindColorAttribute(type, color, attriburesPtr, stylePtr) {\n        if (typeof color === 'undefined')\n            return;\n        if (color === 'none') {\n            attriburesPtr.push(`${type}=\"none\"`);\n        }\n        else {\n            const parsed = color_1.parseColorAndConvert(color);\n            if (parsed) {\n                if (parsed.alpha !== 1) {\n                    stylePtr.push(`${type}-opacity: ${parsed.alpha}`);\n                }\n                attriburesPtr.push(`${type}=\"${color_1.rgbToHex(parsed.r, parsed.g, parsed.b)}\"`);\n            }\n        }\n    }\n    /**\n     * Generate SVG from scene and settings\n     *\n     * @param scene\n     * @param settings\n     * @returns\n     */\n    static generate(scene, settings) {\n        const paths = SVGExporter.generatePaths(scene, settings);\n        let background;\n        if (settings.background) {\n            const attributes = [];\n            const styles = [];\n            SVGExporter.bindColorAttribute('fill', scene.background, attributes, styles);\n            styles.length > 0 && attributes.push(`styles=\"${styles.join('; ')}\"`);\n            background = `<rect width=\"${scene.width}\" height=\"${scene.height}\" ${attributes.length ? attributes.join(' ') + ' ' : ''}/>`;\n        }\n        return (`<svg viewBox=\"0 0 ${scene.width} ${scene.height}\">` +\n            `\\n\\t<!-- Create with Urpflanze <https://docs.urpflanze.org> -->` +\n            (background ? `\\n\\t${background}` : '') +\n            `\\n\\t${paths.join('\\n\\t')}` +\n            `\\n</svg>`);\n    }\n    /**\n     * Convert shapes to paths\n     *\n     * @param scene\n     * @param settings\n     * @returns\n     */\n    static generatePaths(scene, settings) {\n        const paths = [];\n        const sceneChilds = scene.getChildren();\n        for (let i = 0, len = sceneChilds.length; i < len; i++) {\n            sceneChilds[i].generate(0, true);\n            const childBuffer = sceneChilds[i].getBuffer() || [];\n            const childIndexedBuffer = sceneChilds[i].getIndexedBuffer() || [];\n            let childVertexIndex = 0;\n            for (let currentBufferIndex = 0, len = childIndexedBuffer.length; currentBufferIndex < len; currentBufferIndex++) {\n                const currentIndexing = childIndexedBuffer[currentBufferIndex];\n                // Store points\n                const points = [];\n                for (let len = childVertexIndex + currentIndexing.frameLength; childVertexIndex < len; childVertexIndex += 2) {\n                    points.push(childBuffer[childVertexIndex].toFixed(settings.decimals) +\n                        ' ' +\n                        childBuffer[childVertexIndex + 1].toFixed(settings.decimals));\n                }\n                // get styles and bind attributes\n                const propArguments = {\n                    shape: currentIndexing.shape,\n                    repetition: currentIndexing.repetition,\n                    parent: currentIndexing.parent,\n                };\n                const attributes = [];\n                const styles = [];\n                const fill = SVGExporter.getSVGProp('fill', propArguments);\n                SVGExporter.bindColorAttribute('fill', fill || 'none', attributes, styles);\n                const stroke = SVGExporter.getSVGProp('stroke', propArguments, typeof fill === 'undefined' ? scene.color : undefined);\n                SVGExporter.bindColorAttribute('stroke', stroke, attributes, styles);\n                const lineWidth = SVGExporter.getSVGProp('lineWidth', propArguments, 1);\n                if (stroke)\n                    attributes.push(`stroke-width=\"${lineWidth || 1}\"`);\n                // move style to attributes\n                styles.length > 0 && attributes.push(`style=\"${styles.join('; ')}\"`);\n                // build path\n                const d = `M${points.join(' L')} ${currentIndexing.shape.isClosed() ? 'Z' : ''}`;\n                const path = `<path d=\"${d}\" ${attributes.length ? attributes.join(' ') + ' ' : ''}/>`;\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n}\nexports.SVGExporter = SVGExporter;\nSVGExporter.defaults = {\n    decimals: 3,\n    background: true,\n};\n//# sourceMappingURL=SVGExporter.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./conversions\"), exports);\n__exportStar(require(\"./parsing\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rgbToHsl = exports.hslToRgb = exports.rgbToHex = void 0;\n/**\n * Convert rgb to hex\n *\n * @param r number between 0 - 255\n * @param g number between 0 - 255\n * @param b number between 0 - 255\n * @returns #ffffff\n */\nfunction rgbToHex(r, g, b) {\n    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;\n}\nexports.rgbToHex = rgbToHex;\n/**\n * Convert hsl (0-360, 0-100, 0-100) color to rgb(0-255, 0-255, 0-255)\n *\n * @param {number} h number between 0 - 360\n * @param {number} s number between 0 - 100\n * @param {number} l number between 0 - 100\n * @returns {[number, number, number]} [0-255, 0-255, 0-255]\n */\nfunction hslToRgb(h, s, l) {\n    h /= 360;\n    s /= 100;\n    l /= 100;\n    let r, g, b;\n    if (s == 0) {\n        r = g = b = l; // achromatic\n    }\n    else {\n        const hue2rgb = (p, q, t) => {\n            t += t < 0 ? 1 : t > 1 ? -1 : 0;\n            if (t < 1 / 6)\n                return p + (q - p) * 6 * t;\n            if (t < 1 / 2)\n                return q;\n            if (t < 2 / 3)\n                return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return [(0.5 + r * 255) << 0, (0.5 + g * 255) << 0, (0.5 + b * 255) << 0];\n}\nexports.hslToRgb = hslToRgb;\n/**\n * Convert rbg (0-255, 0-255, 0-255) to hsl (0-360, 0-100, 0-100)\n *\n * @param {number} r number between 0 - 255\n * @param {number} g number between 0 - 255\n * @param {number} b number between 0 - 255\n * @returns {[number, number, number]} (0-360, 0-100, 0-100)\n */\nfunction rgbToHsl(r, g, b) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (max + min) / 2;\n    let h, s;\n    if (max === min) {\n        h = s = 0;\n    }\n    else {\n        const d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch (max) {\n            case r:\n                h = (g - b) / d + (g < b ? 6 : 0);\n                break;\n            case g:\n                h = (b - r) / d + 2;\n                break;\n            case b:\n                h = (r - g) / d + 4;\n                break;\n        }\n        h = h / 6;\n    }\n    return [(0.5 + h * 360) << 0, (0.5 + s * 100) << 0, (0.5 + l * 100) << 0];\n}\nexports.rgbToHsl = rgbToHsl;\n//# sourceMappingURL=conversions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseColor = exports.parseColorAndConvert = void 0;\nconst conversions_1 = require(\"./conversions\");\n/**\n * Convert color to IConvertedColor\n * Supported format: 'hsla?' 'rgba?' 'hex{3,8}' number (0xFFFFFF[FF])\n * hsla format: hsla(360, 100%, 100%, 1)\n * rgba format: rgb(255, 255, 255, 1)\n *\n * @param {(string | number)} color\n * @returns {(IConvertedColor | undefined)}\n */\nfunction parseColorAndConvert(color) {\n    const parsed = parseColor(color);\n    if (parsed) {\n        if (parsed.type === 'hsl') {\n            const [r, g, b] = conversions_1.hslToRgb(parsed.a, parsed.b, parsed.c);\n            return {\n                r,\n                g,\n                b,\n                h: parsed.a,\n                s: parsed.b,\n                l: parsed.c,\n                alpha: parsed.alpha,\n            };\n        }\n        else {\n            const [h, s, l] = conversions_1.rgbToHsl(parsed.a, parsed.b, parsed.c);\n            return {\n                h,\n                s,\n                l,\n                r: parsed.a,\n                g: parsed.b,\n                b: parsed.c,\n                alpha: parsed.alpha,\n            };\n        }\n    }\n}\nexports.parseColorAndConvert = parseColorAndConvert;\n/**\n * Convert color to IColor\n * Supported format: 'hsla?' 'rgba?' 'hex{3,8}' number (0xFFFFFF[FF])\n * hsla format: hsla(360, 100%, 100%, 1)\n * rgba format: rgb(255, 255, 255, 1)\n *\n * @param {(string | number)} color\n * @returns {(IColor | undefined)}\n */\nfunction parseColor(color) {\n    if (typeof color === 'number') {\n        if (color > 0xffffff) {\n            return {\n                type: 'rgb',\n                a: (color >> 24) & 255,\n                b: (color >> 16) & 255,\n                c: (color >> 8) & 255,\n                alpha: (color & 255) / 255,\n            };\n        }\n        else {\n            return { type: 'rgb', a: (color >> 16) & 255, b: (color >> 8) & 255, c: color & 255, alpha: 1 };\n        }\n    }\n    color = color.replace(/\\s/g, '');\n    let match = /^#([0-9a-f]{3,8})$/i.exec(color);\n    if (match) {\n        const hex = match[1];\n        if (hex.length === 3) {\n            return {\n                type: 'rgb',\n                a: parseInt(hex[0] + hex[0], 16),\n                b: parseInt(hex[1] + hex[1], 16),\n                c: parseInt(hex[2] + hex[2], 16),\n                alpha: 1,\n            };\n        }\n        else {\n            return {\n                type: 'rgb',\n                a: parseInt(hex[0] + hex[1], 16),\n                b: parseInt(hex[2] + hex[3], 16),\n                c: parseInt(hex[4] + hex[5], 16),\n                alpha: hex.length > 6 ? parseInt(hex.substring(6), 16) / 255 : 1,\n            };\n        }\n    }\n    match = /^((hsl|rgb)a?)\\((\\d+),(\\d+)%?,(\\d+)%?,?(.+)?\\)$/i.exec(color);\n    if (match) {\n        const [, , type, a, b, c, alpha] = match;\n        return {\n            type: type,\n            a: +a,\n            b: +b,\n            c: +c,\n            alpha: alpha ? +alpha : 1,\n        };\n    }\n}\nexports.parseColor = parseColor;\n//# sourceMappingURL=parsing.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(0);\n"],"sourceRoot":""}